// =============================================================================
//
//   HVLayoutForBinTrees.java
//
//   Copyright (c) 2001-2006, Gravisto Team, University of Passau
//
// =============================================================================
// $Id: HVLayout.java 5766 2010-05-07 18:39:06Z gleissner $

package org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.hv;

import java.awt.geom.Point2D;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.graffiti.attributes.Attribute;
import org.graffiti.editor.GraffitiSingleton;
import org.graffiti.graph.Node;
import org.graffiti.graphics.CoordinateAttribute;
import org.graffiti.graphics.GraphicAttributeConstants;
import org.graffiti.plugin.algorithm.AbstractAlgorithm;
import org.graffiti.plugin.algorithm.PreconditionException;
import org.graffiti.plugin.algorithm.PreconditionException.Entry;
import org.graffiti.plugin.parameter.DoubleParameter;
import org.graffiti.plugin.parameter.Parameter;
import org.graffiti.plugin.parameter.SelectionParameter;
import org.graffiti.plugin.parameter.StringSelectionParameter;
import org.graffiti.plugins.algorithms.treedrawings.GraphChecker;
import org.graffiti.plugins.algorithms.treedrawings.Util;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.AtomFinder;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.AtomFinderGeneric;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.AtomFinderHeuristic1;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.AtomFinderHeuristic2;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.CostFunction;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.LayoutComposition;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.LayoutConstants;
import org.graffiti.plugins.algorithms.treedrawings.subtreeSeperation.LayoutRefresher;
import org.graffiti.selection.Selection;

/**
 * This is the algorithm used for laying out trees using an h-v-Layout
 * 
 * @author Andreas
 * @version $Revision: 5766 $ $Date: 2010-05-07 19:21:40 +0200 (Fr, 07 Mai 2010)
 *          $
 */
public class HVLayout extends AbstractAlgorithm {

    /**
     * What to do with the selected Node
     */
    private int selectedNodePolicy;

    /**
     * In this <code>selectedNodePolicy</code> the selected Node is ignored and
     * the graph is laid out as a whole.
     */
    public static final int NONE_TAKE_ALL = 0;

    /**
     * In this <code>selectedNodePolicy</code> only the fixed drawings of the
     * sutrees of the children of the selected Node can be rearranged.
     */
    public static final int ONLY_LOCAL = 1;

    /**
     * In this <code>selectedNodePolicy</code> only the subtree of the selected
     * Node is laid out using a h-v-Layout.
     */
    public static final int DOWNWARDS = 2;

    /** The root of the tree. */
    public Node root = null;

    /** Selection */
    private Selection selection;

    /**
     * The distance between a Node and its children and also the distance
     * between the subtrees of the children.
     */
    private double nodeDistance;

    /**
     * The name of the type of the cost function that is used
     */
    protected String costFunctionName;

    /**
     * This determines whether this layout is generated using the dimensions of
     * the Nodes or if they should be reduced to points.
     */
    protected boolean nodesWithDimensions;

    /**
     * The additional variable which is used for the CostFunction
     * <code>costFunction</code>
     */
    public double additionalVariable;

    /**
     * The parameter for the node dimension (see
     * <code>nodesWithDimensions</code>)
     */
    private StringSelectionParameter nodeDimensionParameter;

    /**
     * The parameter for the node distance (see <code>nodeDistance</code>)
     */
    private DoubleParameter nodeDistanceParameter;

    /**
     * The name of the type of the cost function (see
     * <code>costFunctionName</code>)
     */
    private StringSelectionParameter costFunctionParameter;

    /**
     * The costFunction used in this HVLayout. It is used to determine the
     * optimum h-v-drawing out of the drawings that are generated by the
     * AtomFinder used (depending on the user selection, see
     * <code>selectedAtomFinderStrategy</code>).
     */
    private CostFunction costFunction;

    /**
     * The parameter for the additional variable (see
     * <code>additionalVariable</code>)
     */
    private DoubleParameter additionalVariableParameter;

    /**
     * The selected node. What to do with it is determined by
     * <code>selectedNodePolicy</code>
     */
    private Node selectedNode;

    /**
     * The LayoutRefresher used in this HVLayout.
     */
    private LayoutRefresher layoutRefresher;

    /**
     * The reconstructed LayoutCompositions of the subtrees of the children of
     * <code>selected</code>, if <code>selectedNodePolicy</code> is
     * <code>ONLY_LOCAL</code>.
     */
    private List<LayoutComposition> reconstructedCompositions;

    /**
     * The parameter for <code>selectedNodePolicy</code>
     */
    private StringSelectionParameter selectedNodePolicyParameter;

    /**
     * The parameter for <code>selectedAtomFinderStrategy</code>
     */
    private StringSelectionParameter atomFinderStrategyParameter;

    /**
     * The name of the AtomFinder that should be used.
     */
    private String selectedAtomFinderStrategy;

    /**
     * set the <code>nodeDistance</code>
     * 
     * @param nodeDistance
     */
    public void setNodeDistance(double nodeDistance) {
        this.nodeDistance = nodeDistance;
    }

    /**
     * set the variable <code>costFunctionName</code>
     * 
     * @param costFunctionName
     */
    public void setCostFunctionName(String costFunctionName) {
        this.costFunctionName = costFunctionName;
    }

    /**
     * Set the policy for the selected node.
     * 
     * @param selectedNodePolicy
     */
    public void setSelectedNodePolicy(int selectedNodePolicy) {
        this.selectedNodePolicy = selectedNodePolicy;
    }

    /**
     * Set the selected Node (for non-GUI use).
     * 
     * @param selectedNode
     */
    public void setSelectedNode(Node selectedNode) {
        this.selectedNode = selectedNode;
    }

    /**
     * Set the name of the AtomFinder to be used (for non-GUI use).
     * 
     * @param strategy
     */
    public void setAtomFinderStrategy(String strategy) {
        this.selectedAtomFinderStrategy = strategy;
    }

    /**
     * Set the variable <code>nodesWithDimensions</code> (for non-GUI use).
     * 
     * @param nodesWithDimensions
     */
    public void setNodesWithDimensions(boolean nodesWithDimensions) {
        this.nodesWithDimensions = nodesWithDimensions;
    }

    /**
     * Set the variable <code>additionalVariable</code> (for non-GUI use).
     * 
     * @param additionalVariable
     */
    public void setAdditionalVariable(double additionalVariable) {
        this.additionalVariable = additionalVariable;
    }

    /**
     * Create a new HVLayout.
     */
    public HVLayout() {
        String[] nodeDimensionParameterNames = new String[] { "POINT_NODES",
                "NODES_WITH_DIMENSIONS" };
        this.nodeDimensionParameter = new StringSelectionParameter(
                nodeDimensionParameterNames, "Node Dimension", "...");

        this.selectedNodePolicyParameter = new StringSelectionParameter(
                new String[] { "NONE_TAKE_ALL", "DOWNWARDS", "ONLY_LOCAL" },
                "Selected Node Policy", "Only if Nodes selected");

        this.nodeDistanceParameter = new DoubleParameter(new Double(50),
                "Distance Between Nodes:", "...");

        this.costFunctionParameter = new StringSelectionParameter(
                CostFunction.costFunctionNames, "Cost Function", "..");

        this.additionalVariableParameter = new DoubleParameter(new Double(200),
                "Constraint or Aspect Ratio",
                "(needed for some costfunctions)", new Double(0), new Double(
                        1000));

        this.atomFinderStrategyParameter = new StringSelectionParameter(
                new String[] { "GENERIC", "HEURISTIC1", "HEURISTIC2" },
                "AtomFinder Strategy", "...");
    }

    /**
     * @see org.graffiti.plugin.algorithm.Algorithm#getName()
     */
    public String getName() {
        return "HVLayout Algorithm";
    }

    @Override
    public Parameter<?>[] getAlgorithmParameters() {
        SelectionParameter seleParam = new SelectionParameter("Root:",
                "Root of this tree.");

        return new Parameter[] { seleParam, this.nodeDimensionParameter,
                this.selectedNodePolicyParameter, this.nodeDistanceParameter,
                this.costFunctionParameter, this.additionalVariableParameter,
                this.atomFinderStrategyParameter };

    }

    /**
     * @see org.graffiti.plugin.AbstractParametrizable#setAlgorithmParameters(Parameter[])
     */
    @Override
    public void setAlgorithmParameters(Parameter<?>[] params) {

        this.selection = ((SelectionParameter) params[0]).getSelection();

        String nodeDimensionName = ((StringSelectionParameter) params[1])
                .getValue();

        if (nodeDimensionName.equals("POINT_NODES")) {
            this.nodesWithDimensions = false;
        } else if (nodeDimensionName.equals("NODES_WITH_DIMENSIONS")) {
            this.nodesWithDimensions = true;
        }

        String selectedNodePolicyName = ((StringSelectionParameter) params[2])
                .getValue();
        if (selectedNodePolicyName.equals("NONE_TAKE_ALL")) {
            this.selectedNodePolicy = HVLayout.NONE_TAKE_ALL;
        } else if (selectedNodePolicyName.equals("ONLY_LOCAL")) {
            this.selectedNodePolicy = HVLayout.ONLY_LOCAL;
        } else if (selectedNodePolicyName.equals("DOWNWARDS")) {
            this.selectedNodePolicy = HVLayout.DOWNWARDS;
        }

        this.nodeDistance = ((DoubleParameter) params[3]).getDouble();

        this.costFunctionName = ((StringSelectionParameter) params[4])
                .getSelectedValue();

        this.additionalVariable = ((DoubleParameter) params[5]).getDouble();

        this.selectedAtomFinderStrategy = ((StringSelectionParameter) params[6])
                .getValue();

    }

    /**
     * Check the following:<BR>
     * <BR>
     * 1. Is the given Graph a tree?<BR>
     * 2. If <code>selectedNodePolicy</code> is <code>NONE_TAKE_ALL</code>: Does
     * the given tree have a degree of at most 2?<BR>
     * 3. If <code>selectedNodePolicy</code> is <code>ONLY_LOCAL</code>: Does
     * the selected Node have at most 2 children? Do all necessary
     * layout-Attributes exist in the subtrees of the children of
     * <code>selectedNode</code>?<BR>
     * 4. If <code>selectedNodePolicy</code> is <code>DOWNWARDS</code>: Is the
     * subtree of <code>selectedNode</code> a binary tree and is the graph as a
     * whole a tree?<BR>
     * 
     * @see org.graffiti.plugin.algorithm.Algorithm#check()
     */
    @Override
    public void check() throws PreconditionException {

        this.layoutRefresher = new LayoutRefresher();

        int maxDegreeGlobal = Integer.MAX_VALUE;

        if (this.selectedNodePolicy == HVLayout.NONE_TAKE_ALL) {
            maxDegreeGlobal = 2;
        }

        try {
            this.root = GraphChecker.checkTree(this.graph, maxDegreeGlobal);

            if (this.selectedNodePolicy == HVLayout.DOWNWARDS
                    || this.selectedNodePolicy == HVLayout.ONLY_LOCAL) {
                if (this.selection.getNodes().size() != 1)
                    throw new PreconditionException(
                            "Please select exactly one Node.");
                this.selectedNode = this.selection.getNodes().get(0);

                LinkedList<Node> violatingNodes = new LinkedList<Node>();
                String message = null;

                if (this.selectedNodePolicy == HVLayout.ONLY_LOCAL) {
                    if (this.selectedNode.getOutDegree() > 2) {
                        message = "The selected Node has more than two children.";
                        violatingNodes.add(this.selectedNode);
                    }
                } else {
                    Util.findNodesWithOutDegreeMoreThan(this.selectedNode, 2,
                            violatingNodes);
                    message = "The selected node's subtree has nodes with outDegree > 2. "
                            + "They will be selected.";

                }

                if (violatingNodes.size() > 0) {
                    Selection selection = new Selection();
                    selection.addAll(violatingNodes);
                    PreconditionException errors = new PreconditionException();
                    errors.add(message, selection);
                    throw errors;
                }

                if (this.selectedNodePolicy == HVLayout.ONLY_LOCAL) {
                    this.reconstructedCompositions = new LinkedList<LayoutComposition>();

                    for (Node currentChildNode : this.selectedNode
                            .getAllOutNeighbors()) {
                        this.reconstructedCompositions.add(this.layoutRefresher
                                .reconstructComposition(currentChildNode));
                    }
                }
            }

        } catch (PreconditionException p) {
            if (this.selection != null) {
                this.selection.clear();
            } else {
                this.selection = new Selection();
            }

            Iterator<Entry> itr = p.iterator();
            while (itr.hasNext()) {
                Selection selection = (Selection) itr.next().source;
                if (selection != null) {
                    this.selection.addSelection(selection);
                }
            }
            throw p;
        }

    }

    /*
     * Create a h-v-Layout using the parameters and modes described above.
     * 
     * @see org.graffiti.plugin.algorithm.Algorithm#execute()
     */
    public void execute() {
        this.graph.getListenerManager().transactionStarted(this);

        /**
         * create the HVComposition factory. Only a dummy HVCompsotion object is
         * needed here to initialize the factory.
         */

        long startTime = System.currentTimeMillis();

        LayoutComposition compositionFactory = new HVComposition();

        AtomFinder atomFinder = null;
        if (this.selectedNodePolicy != HVLayout.ONLY_LOCAL) {
            if (selectedAtomFinderStrategy.equals("HEURISTIC1")) {
                atomFinder = new AtomFinderHeuristic1(compositionFactory,
                        this.nodeDistance, this.nodesWithDimensions);
            } else if (selectedAtomFinderStrategy.equals("HEURISTIC2")) {
                atomFinder = new AtomFinderHeuristic2(compositionFactory,
                        this.nodeDistance, this.nodesWithDimensions);
            } else {
                atomFinder = new AtomFinderGeneric(compositionFactory,
                        this.nodeDistance, this.nodesWithDimensions);
            }
        }

        LayoutConstants.setMinimumHeightAndWidth(this.graph);

        List<LayoutComposition> atoms = null;

        if (this.selectedNodePolicy == HVLayout.NONE_TAKE_ALL) {
            atoms = atomFinder.findAtoms(this.root);
        } else if (this.selectedNodePolicy == HVLayout.DOWNWARDS) {
            atoms = atomFinder.findAtoms(this.selectedNode);
        } else if (this.selectedNodePolicy == HVLayout.ONLY_LOCAL) {

            List<LayoutComposition> horizontalComposition = compositionFactory
                    .instance(this.selectedNode,
                            this.reconstructedCompositions, true,
                            this.nodeDistance, this.nodesWithDimensions);
            List<LayoutComposition> verticalComposition = compositionFactory
                    .instance(this.selectedNode,
                            this.reconstructedCompositions, false,
                            this.nodeDistance, this.nodesWithDimensions);

            atoms = new LinkedList<LayoutComposition>();
            atoms.addAll(horizontalComposition);
            atoms.addAll(verticalComposition);
        } else
            throw new IllegalStateException("Unknown Selected Node policy.");

        this.costFunction = new CostFunction(this.costFunctionName,
                this.additionalVariable);

        LayoutComposition bestFound = null;

        try {
            bestFound = this.costFunction.findBestAtom(atoms);
        } catch (IllegalStateException i) {
            throw i;
        }

        if (bestFound != null) {
            long timeNeeded = System.currentTimeMillis() - startTime;

            startTime = System.currentTimeMillis();

            bestFound.setLayoutAttributes(false);

            String warningMessage = "";

            // try if we can refresh the whole thing...
            try {
                LayoutComposition wholeGraphComposition = this.layoutRefresher
                        .reconstructComposition(this.root);
                wholeGraphComposition.layout(new Point2D.Double(0, 0));
            } catch (PreconditionException p) {
                warningMessage = "WARNING: Could not layout the whole graph (only the subtree). Use LayoutRefresher!";

                try {
                    LayoutComposition subtreeComposition = this.layoutRefresher
                            .reconstructComposition(this.selectedNode);

                    CoordinateAttribute ca = (CoordinateAttribute) bestFound
                            .getRoot()
                            .getAttribute(
                                    GraphicAttributeConstants.GRAPHICS
                                            + Attribute.SEPARATOR
                                            + GraphicAttributeConstants.COORDINATE);

                    subtreeComposition.layout(ca.getCoordinate());
                } catch (PreconditionException e) {
                    // This should never happen
                    e.printStackTrace();
                }
            }

            long timeNeededForLayout = System.currentTimeMillis() - startTime;

            String message = warningMessage + "Width: " + bestFound.getWidth()
                    + ", Height: " + bestFound.getHeight()
                    + ", value of costfunction: "
                    + this.costFunction.costOf(bestFound)
                    + ", h-v-Layout found after: " + timeNeeded + "ms, "
                    + "Time needed for layouting GraphElements: "
                    + timeNeededForLayout + "ms";

            try {
                GraffitiSingleton.getInstance().getMainFrame().getStatusBar()
                        .showInfo(message, 60000);
            } catch (NullPointerException n) {
                // Never mind
            }

            System.out.println(message);
            // System.out.println("Selected Atom:\n" +
            // bestFound.showStructure());
        }
        this.graph.getListenerManager().transactionFinished(this);

    }

}

// -----------------------------------------------------------------------------
// end of file
// -----------------------------------------------------------------------------
