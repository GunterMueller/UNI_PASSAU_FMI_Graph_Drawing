<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
      <title>GTL - Graph Template Library: bfs Class Reference</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <p class="links">  
      <a href="../index.html">Home</a> |
      Documentation |
      <a href="../register.html">Download</a> |
      <a href="../platforms.html">Platforms</a> |
      <a href="../refer.html">Projects</a> |      
      <a href="../lists.html">Mailing Lists</a> |
      <a href="../history.html">Version History</a>
    </p>

<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>bfs Class Reference</h1><!-- doxytag: class="bfs" --><!-- doxytag: inherits="algorithm" -->Breadth-First-Search (BFS) algorithm.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for bfs:</div>
<div class="dynsection">
<p><center><img src="a00110.gif" border="0" usemap="#a00111" alt="Inheritance graph"></center>
<map name="a00111">
<area shape="rect" href="a00001.html" title="Abstract baseclass for all algoritm&#45;classes." alt="" coords="5,7,83,31"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for bfs:</div>
<div class="dynsection">
<p><center><img src="a00112.gif" border="0" usemap="#a00113" alt="Collaboration graph"></center>
<map name="a00113">
<area shape="rect" href="a00001.html" title="Abstract baseclass for all algoritm&#45;classes." alt="" coords="401,5,479,29"><area shape="rect" href="a00020.html" title="A node in a graph." alt="" coords="415,92,465,116"><area shape="rect" title="start" alt="" coords="463,103,471,111"><area shape="rect" title="start" alt="" coords="636,123,644,131"><area shape="rect" title="int_node" alt="" coords="411,89,419,97"><area shape="rect" title="int_node" alt="" coords="463,89,471,97"><area shape="rect" href="a00021.html" title="node_map\&lt; int \&gt;" alt="" coords="379,145,501,169"><area shape="rect" title="bfs_number\nlevel_number" alt="" coords="497,164,505,172"><area shape="rect" title="bfs_number\nlevel_number" alt="" coords="643,139,651,147"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, int, graph, allocator\&lt; int \&gt; \&gt;" alt="" coords="21,145,304,169"><area shape="rect" href="a00021.html" title="node_map\&lt; node \&gt;" alt="" coords="371,193,509,217"><area shape="rect" title="preds" alt="" coords="505,209,513,217"><area shape="rect" title="preds" alt="" coords="651,139,659,147"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, node, graph, allocator\&lt; node \&gt; \&gt;" alt="" coords="5,193,320,217"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00114.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0b58a03ca2fc32117948ab27a806bd1"></a><!-- doxytag: member="bfs::tree_edges_iterator" ref="a0b58a03ca2fc32117948ab27a806bd1" args="" -->
typedef list&lt; <a class="el" href="a00010.html">edge</a> &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a0b58a03ca2fc32117948ab27a806bd1">tree_edges_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for tree-edges. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cafce54954100cc7bc9f80eb318a7bee"></a><!-- doxytag: member="bfs::bfs_iterator" ref="cafce54954100cc7bc9f80eb318a7bee" args="" -->
typedef list&lt; <a class="el" href="a00020.html">node</a> &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for nodes in BFS-order. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ecd86c7c1f1086d4b6b11c2a0eb12afe"></a><!-- doxytag: member="bfs::non_tree_edges_iterator" ref="ecd86c7c1f1086d4b6b11c2a0eb12afe" args="" -->
typedef list&lt; <a class="el" href="a00010.html">edge</a> &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ecd86c7c1f1086d4b6b11c2a0eb12afe">non_tree_edges_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for non-tree-edges. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="386ac6f3c63e38c3f5263e15c3ab9d01"></a><!-- doxytag: member="bfs::roots_iterator" ref="386ac6f3c63e38c3f5263e15c3ab9d01" args="" -->
typedef list<br>
&lt; <a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a> &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#386ac6f3c63e38c3f5263e15c3ab9d01">roots_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for roots of trees in BFS-forest. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a47a4c97f240c4745c9890524e746bf4"></a><!-- doxytag: member="bfs::bfs" ref="a47a4c97f240c4745c9890524e746bf4" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a47a4c97f240c4745c9890524e746bf4">bfs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e38bc9acd4cf02a748886f2fc0d88557"></a><!-- doxytag: member="bfs::~bfs" ref="e38bc9acd4cf02a748886f2fc0d88557" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#e38bc9acd4cf02a748886f2fc0d88557">~bfs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#06ae16bd0f3bb2f8eb6b3e36659ba82e">run</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies algorithm to graph g.  <a href="#06ae16bd0f3bb2f8eb6b3e36659ba82e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#6dd7e852f7768814aafba8962befca56">check</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the preconditions for BFS are satisfied.  <a href="#6dd7e852f7768814aafba8962befca56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#355b797efe46ab262e71c05ba75de940">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets algorithm.  <a href="#355b797efe46ab262e71c05ba75de940"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#23e2981c2ee617a6e12a8833d2db6210">start_node</a> (const <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets start-node for BFS.  <a href="#23e2981c2ee617a6e12a8833d2db6210"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#c5cf27683ad751cd6e4129141fc9b495">start_node</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns start-node for BFS.  <a href="#c5cf27683ad751cd6e4129141fc9b495"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b">scan_whole_graph</a> (bool set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables scanning of the whole graph.  <a href="#25fc51b1bfbbdd3afefe0a84c1bd2f6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#d698825ec64edfa808210de913a922d3">scan_whole_graph</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the whole <a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a> will be scanned.  <a href="#d698825ec64edfa808210de913a922d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#491515da4eb8efca0be4fef0df350a8e">calc_level</a> (bool set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the calculation of level-numbers for each node.  <a href="#491515da4eb8efca0be4fef0df350a8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#8a67bff3ab12226cf8f4bea4a14bd183">calc_level</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether level-numbers will be calculated.  <a href="#8a67bff3ab12226cf8f4bea4a14bd183"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#7de47b820fb9532f497660f767c9457f">store_non_tree_edges</a> (bool set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the storing of non-tree-edges.  <a href="#7de47b820fb9532f497660f767c9457f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#9e16858479ee2b4980b4dbe73202a9d6">store_non_tree_edges</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the storing of non-tree-edges is enabled.  <a href="#9e16858479ee2b4980b4dbe73202a9d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#8c7ce0ea2cd8e1932d1da5693d90cf61">store_preds</a> (bool set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the storing of predecessors.  <a href="#8c7ce0ea2cd8e1932d1da5693d90cf61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#1b73eb7f1fb984331781da890bd45029">store_preds</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the storing of predecessors is enabled.  <a href="#1b73eb7f1fb984331781da890bd45029"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a91531970fa0eb1c7e18d5455f54fe9f">reached</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether node <em>n</em> was reached in BFS.  <a href="#a91531970fa0eb1c7e18d5455f54fe9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ad3b67493e3d936f8ca3d1fe38d72842">bfs_num</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BFS-number of <em>n</em>.  <a href="#ad3b67493e3d936f8ca3d1fe38d72842"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#01e0e18c3478faf9ea6b9140c1cc4102">operator[]</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BFS-number of <em>n</em>.  <a href="#01e0e18c3478faf9ea6b9140c1cc4102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#db141187b9b6c9fc78089eb87ba19ad4">level</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Level-number of node <em>n</em>.  <a href="#db141187b9b6c9fc78089eb87ba19ad4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#eff99e4f0142cbb9977503844c0d45c9">father</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Father of node <em>n</em> in BFS-forest.  <a href="#eff99e4f0142cbb9977503844c0d45c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#a0b58a03ca2fc32117948ab27a806bd1">tree_edges_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#50fbe73f807b39845bb2334548c9b8cb">tree_edges_begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate through all tree-edges of last BFS.  <a href="#50fbe73f807b39845bb2334548c9b8cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#a0b58a03ca2fc32117948ab27a806bd1">tree_edges_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#609773f0e8e94dbdd330d5363c6d610c">tree_edges_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End-iterator for iteration through all tree-edges picked of last BFS.  <a href="#609773f0e8e94dbdd330d5363c6d610c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#7b83a88f71f210946be3ef212f4c2c37">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate through all (reached) nodes in BFS-Order.  <a href="#7b83a88f71f210946be3ef212f4c2c37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#b1a9a095e1e757e8f71ba752bf0e898d">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End-iterator for iteration through all (reached) nodes in BFS-Order.  <a href="#b1a9a095e1e757e8f71ba752bf0e898d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#ecd86c7c1f1086d4b6b11c2a0eb12afe">non_tree_edges_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#0c7c3cb97a538907ddd0dc39bd884ffc">non_tree_edges_begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate through all non-tree-edges (if enabled).  <a href="#0c7c3cb97a538907ddd0dc39bd884ffc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#ecd86c7c1f1086d4b6b11c2a0eb12afe">non_tree_edges_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#37645ce2ffc6fb95afb56477025a64a8">non_tree_edges_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End-iterator for iteration through all non-tree-edges (if enabled).  <a href="#37645ce2ffc6fb95afb56477025a64a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#386ac6f3c63e38c3f5263e15c3ab9d01">roots_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ae9df31655e7ef516426dfb99c2de888">roots_begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing towards the first root in the BFS-forest.  <a href="#ae9df31655e7ef516426dfb99c2de888"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00003.html#386ac6f3c63e38c3f5263e15c3ab9d01">roots_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#31e77fd48aed1902d488a54f2f0ef6f8">roots_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to the end of all roots.  <a href="#31e77fd48aed1902d488a54f2f0ef6f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#50ca0ee41753b59ed7adfe9f60adf1e4">number_of_reached_nodes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of nodes reached in last BFS.  <a href="#50ca0ee41753b59ed7adfe9f60adf1e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#b9af608a9b2d570a8688498bc3c53d7f">init_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called at the start of BFS.  <a href="#b9af608a9b2d570a8688498bc3c53d7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#d99b9aeb177a8a2e0ce1c3673082cddf">end_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called right before the end of BFS.  <a href="#d99b9aeb177a8a2e0ce1c3673082cddf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#3f161fe9f45e0a69892f355a889c3516">popped_node_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G, <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after the node <em>n</em> was taken out of the queue.  <a href="#3f161fe9f45e0a69892f355a889c3516"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#db6604080f3376e9713e35cd9d7d8943">finished_node_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G, <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when finished with the node <em>n</em>.  <a href="#db6604080f3376e9713e35cd9d7d8943"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#0e45c8fe90e54bffe18b308868ccc111">unused_node_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G, <a class="el" href="a00020.html">node</a> &amp;n, <a class="el" href="a00020.html">node</a> &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when an unused node <em>n</em> was discovered.  <a href="#0e45c8fe90e54bffe18b308868ccc111"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#d2cbb1e9c36f561da0c91fd142296f2a">used_node_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G, <a class="el" href="a00020.html">node</a> &amp;n, <a class="el" href="a00020.html">node</a> &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when an used node <em>n</em> was found.  <a href="#d2cbb1e9c36f561da0c91fd142296f2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#4f33f10121240390a5a50b5efc16c1f5">new_start_handler</a> (<a class="el" href="a00014.html">graph</a> &amp;G, <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when BFS is started with start-node <em>n</em>.  <a href="#4f33f10121240390a5a50b5efc16c1f5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a4adad9562896536b8b58ab237e8478"></a><!-- doxytag: member="bfs::act_bfs_num" ref="5a4adad9562896536b8b58ab237e8478" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#5a4adad9562896536b8b58ab237e8478">act_bfs_num</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BFS number that will be assigned next. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff965242124a7e3a6308de0c0ebfa741"></a><!-- doxytag: member="bfs::qu" ref="ff965242124a7e3a6308de0c0ebfa741" args="" -->
deque&lt; <a class="el" href="a00020.html">node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ff965242124a7e3a6308de0c0ebfa741">qu</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">queue used in BFS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">list&lt; <a class="el" href="a00020.html">node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#35b0acd44887615142fd5f2fc6197452">bfs_order</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of nodes in BFS-order.  <a href="#35b0acd44887615142fd5f2fc6197452"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">list&lt; <a class="el" href="a00010.html">edge</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a259f09ada9928cda41bcb540f685e80">tree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of all edges of the BFS-tree.  <a href="#a259f09ada9928cda41bcb540f685e80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59d0c5c5ad2715776b20b1aec03dbc3a"></a><!-- doxytag: member="bfs::bfs_number" ref="59d0c5c5ad2715776b20b1aec03dbc3a" args="" -->
<a class="el" href="a00021.html">node_map</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#59d0c5c5ad2715776b20b1aec03dbc3a">bfs_number</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores BFS-number of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3db80b59d5db049199936445a6c2da8"></a><!-- doxytag: member="bfs::reached_nodes" ref="c3db80b59d5db049199936445a6c2da8" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#c3db80b59d5db049199936445a6c2da8">reached_nodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of nodes reached so far. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">list&lt; <a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#79d19028002766f7992fe94689217f99">roots</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of all roots of the BFS-tree.  <a href="#79d19028002766f7992fe94689217f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#6c08fbcc90d71f1cbdd03a1cdaa9dc99">whole_graph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores whether whole graph will be scanned.  <a href="#6c08fbcc90d71f1cbdd03a1cdaa9dc99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#f2ab561d9e60a9fc2e25b02d1f807f96">start</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores start node.  <a href="#f2ab561d9e60a9fc2e25b02d1f807f96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00021.html">node_map</a>&lt; int &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#ab92e9d128612c28324aafe4750dbc84">level_number</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores level number of each node (if enabled).  <a href="#ab92e9d128612c28324aafe4750dbc84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">list&lt; <a class="el" href="a00010.html">edge</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#a6783e3e2ac4235403b37df3ee3ee968">non_tree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of non-tree edges (if enabled).  <a href="#a6783e3e2ac4235403b37df3ee3ee968"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00021.html">node_map</a>&lt; <a class="el" href="a00020.html">node</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html#3bac5ed333bb78a30a67099c3b94aa0c">preds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores father of each node (if enabled).  <a href="#3bac5ed333bb78a30a67099c3b94aa0c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Breadth-First-Search (BFS) algorithm. 
<p>
<dl class="rcs" compact><dt><b>Date</b></dt><dd></dd></dl>
<dl class="rcs" compact><dt><b>Revision</b></dt><dd></dd></dl>
<p>
Encapsulates the BFS algorithm together with all data produced by it. There are a few parameters, which on the one hand influence the behaviour of BFS (e.g. <a class="el" href="a00003.html#23e2981c2ee617a6e12a8833d2db6210" title="Sets start-node for BFS.">bfs::start_node</a>) and on the other hand toggle the storing of extra information, such as the level-number of each node. In detail these are:<ul>
<li><a class="el" href="a00003.html#23e2981c2ee617a6e12a8833d2db6210" title="Sets start-node for BFS.">bfs::start_node</a> (default: an arbitrary node will be chosen)</li><li><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> states whether BFS will be continued in the unused part of the graph, if not all nodes were touched at the end of BFS started at the start-node. (default: disabled)</li><li><a class="el" href="a00003.html#491515da4eb8efca0be4fef0df350a8e" title="Enables or disables the calculation of level-numbers for each node.">bfs::calc_level</a> toggle storing of level-numbers for each node, i.e. its distance from the start-node. (default: disabled)</li><li><a class="el" href="a00003.html#8c7ce0ea2cd8e1932d1da5693d90cf61" title="Enables or disables the storing of predecessors.">bfs::store_preds</a> toggle storing the predecessor of each node, i.e. the father in the BFS-tree. (default: disabled)</li><li><a class="el" href="a00003.html#7de47b820fb9532f497660f767c9457f" title="Enables or disables the storing of non-tree-edges.">bfs::store_non_tree_edges</a> toggle storing of all non_tree_edges (tree_edges are always stored) in a list and thus enable or disable iteration through all non_tree_edges. (default: disabled)</li></ul>
<p>
<em>Please</em> <em>note</em> that the algorithm always starts with the given start-node (if none was given, the first node is chosen and stored, thus after BFS the root of the tree is always accesible via <a class="el" href="a00003.html#23e2981c2ee617a6e12a8833d2db6210" title="Sets start-node for BFS.">bfs::start_node</a>) and continues until no more unused nodes are reachable from already used ones. Thus if the graph isn't connected not <em>all</em> nodes will be reached. If <a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> isn't set the BFS stops here. If it is set, the BFS will be continued with the next unused node and so on until all nodes were used.<p>
For further customization a few virtual functions, so called handler, are called at crucial stages of the algorithm. In this basic implementation all of these handler are empty. So if one wants to add only a few lines of code (e.g. some new numbering) he is likely to take this class as base-class and override the handler where neccessary. In detail these are (please look at the source code to see where they are called):<ul>
<li><a class="el" href="a00003.html#b9af608a9b2d570a8688498bc3c53d7f" title="Called at the start of BFS.">bfs::init_handler</a></li><li><a class="el" href="a00003.html#d99b9aeb177a8a2e0ce1c3673082cddf" title="Called right before the end of BFS.">bfs::end_handler</a></li><li><a class="el" href="a00003.html#3f161fe9f45e0a69892f355a889c3516" title="Called after the node n was taken out of the queue.">bfs::popped_node_handler</a></li><li><a class="el" href="a00003.html#db6604080f3376e9713e35cd9d7d8943" title="Called when finished with the node n.">bfs::finished_node_handler</a></li><li><a class="el" href="a00003.html#0e45c8fe90e54bffe18b308868ccc111" title="Called when an unused node n was discovered.">bfs::unused_node_handler</a></li><li><a class="el" href="a00003.html#d2cbb1e9c36f561da0c91fd142296f2a" title="Called when an used node n was found.">bfs::used_node_handler</a></li><li><a class="el" href="a00003.html#4f33f10121240390a5a50b5efc16c1f5" title="Called when BFS is started with start-node n.">bfs::new_start_handler</a></li></ul>
<p>
<em>Please</em> <em>note:</em> We do <em>not</em> claim that the set of handlers provided is sufficient in any way. So if you believe that some new handler is needed urgently please let us know.<p>
There is a lot of information stored during BFS (e.g. nodes in bfs-order, list of non-tree edges). Some of it can be obtained directly by using the corresponding member-function (e.g. <a class="el" href="a00003.html#ad3b67493e3d936f8ca3d1fe38d72842" title="BFS-number of n.">bfs::bfs_num</a>), but all information that can be thought of as a list (e.g. nodes in bfs-order) can be accessed through iterators. In detail these are (of course depending on what options are chosen!):<ul>
<li><a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee" title="Iterator for nodes in BFS-order.">bfs::bfs_iterator</a></li><li><a class="el" href="a00003.html#a0b58a03ca2fc32117948ab27a806bd1" title="Iterator for tree-edges.">bfs::tree_edges_iterator</a></li><li><a class="el" href="a00003.html#ecd86c7c1f1086d4b6b11c2a0eb12afe" title="Iterator for non-tree-edges.">bfs::non_tree_edges_iterator</a></li><li><a class="el" href="a00003.html#386ac6f3c63e38c3f5263e15c3ab9d01" title="Iterator for roots of trees in BFS-forest.">bfs::roots_iterator</a> </li></ul>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="06ae16bd0f3bb2f8eb6b3e36659ba82e"></a><!-- doxytag: member="bfs::run" ref="06ae16bd0f3bb2f8eb6b3e36659ba82e" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bfs::run           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies algorithm to graph g. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>graph </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a></em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67106fcf574690bbd6cf710837a169510dd7">algorithm::GTL_ERROR</a></em>&nbsp;</td><td>otherwise </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="a00001.html#734b189509a8d6b56b65f8ff772d43ca">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="6dd7e852f7768814aafba8962befca56"></a><!-- doxytag: member="bfs::check" ref="6dd7e852f7768814aafba8962befca56" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bfs::check           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the preconditions for BFS are satisfied. 
<p>
Currently there aren't any restricitions for the BFS algorithm.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td><a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a></em>&nbsp;</td><td>if algorithm can be applied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67106fcf574690bbd6cf710837a169510dd7">algorithm::GTL_ERROR</a></em>&nbsp;</td><td>otherwise. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="a00001.html#76361fb03ad1cf643affc51821e43bed">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="355b797efe46ab262e71c05ba75de940"></a><!-- doxytag: member="bfs::reset" ref="355b797efe46ab262e71c05ba75de940" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets algorithm. 
<p>
Prepares the algorithm to be applied to another graph. <em>Please</em> <em>note:</em> The options an algorithm may support do <em>not</em> get reset by this. It is just to reset internally used datastructures. 
<p>Implements <a class="el" href="a00001.html#21aba63d066ae7897de6ca7d8425c408">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="23e2981c2ee617a6e12a8833d2db6210"></a><!-- doxytag: member="bfs::start_node" ref="23e2981c2ee617a6e12a8833d2db6210" args="(const node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bfs::start_node           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets start-node for BFS. 
<p>
The default start-node is the invalid node (<a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a>), in this case an arbitrary node is chosen and stored when BFS is run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>start-node. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c5cf27683ad751cd6e4129141fc9b495"></a><!-- doxytag: member="bfs::start_node" ref="c5cf27683ad751cd6e4129141fc9b495" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> bfs::start_node           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns start-node for BFS. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>start-node. </dd></dl>

</div>
</div><p>
<a class="anchor" name="25fc51b1bfbbdd3afefe0a84c1bd2f6b"></a><!-- doxytag: member="bfs::scan_whole_graph" ref="25fc51b1bfbbdd3afefe0a84c1bd2f6b" args="(bool set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bfs::scan_whole_graph           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables scanning of the whole graph. 
<p>
If enabled and the BFS started at the given start-node stops without having touched all nodes, it will be continued with the next unused node, and so on until all nodes were used. This makes sure that for every node <a class="el" href="a00003.html#ad3b67493e3d936f8ca3d1fe38d72842" title="BFS-number of n.">bfs::bfs_num</a> is defined.<p>
If this feature is disabled, you are able to check what nodes can be reached, when starting a BFS at the start-node, because for those not reached <a class="el" href="a00003.html#ad3b67493e3d936f8ca3d1fe38d72842" title="BFS-number of n.">bfs::bfs_num</a> will be 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>if true enable scanning the whole graph. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#ae9df31655e7ef516426dfb99c2de888" title="Iterator pointing towards the first root in the BFS-forest.">bfs::roots_begin</a>, <a class="el" href="a00003.html#31e77fd48aed1902d488a54f2f0ef6f8" title="Iterator pointing to the end of all roots.">bfs::roots_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d698825ec64edfa808210de913a922d3"></a><!-- doxytag: member="bfs::scan_whole_graph" ref="d698825ec64edfa808210de913a922d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bfs::scan_whole_graph           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the whole <a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a> will be scanned. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>iff the whole <a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a> will be scanned. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#ae9df31655e7ef516426dfb99c2de888" title="Iterator pointing towards the first root in the BFS-forest.">bfs::roots_begin</a>, <a class="el" href="a00003.html#31e77fd48aed1902d488a54f2f0ef6f8" title="Iterator pointing to the end of all roots.">bfs::roots_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="491515da4eb8efca0be4fef0df350a8e"></a><!-- doxytag: member="bfs::calc_level" ref="491515da4eb8efca0be4fef0df350a8e" args="(bool set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bfs::calc_level           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the calculation of level-numbers for each node. 
<p>
If enabled each node gets a level-number, i.e. its distance from the start-node.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>if true level-number will be calculated. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#db141187b9b6c9fc78089eb87ba19ad4" title="Level-number of node n.">bfs::level</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a67bff3ab12226cf8f4bea4a14bd183"></a><!-- doxytag: member="bfs::calc_level" ref="8a67bff3ab12226cf8f4bea4a14bd183" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bfs::calc_level           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether level-numbers will be calculated. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>iff level-numbers will be calculated. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#db141187b9b6c9fc78089eb87ba19ad4" title="Level-number of node n.">bfs::level</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7de47b820fb9532f497660f767c9457f"></a><!-- doxytag: member="bfs::store_non_tree_edges" ref="7de47b820fb9532f497660f767c9457f" args="(bool set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bfs::store_non_tree_edges           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the storing of non-tree-edges. 
<p>
If enabled all non-tree-edges will be stored in the order they occured.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>if true non-tree-edges will be stored. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#0c7c3cb97a538907ddd0dc39bd884ffc" title="Iterate through all non-tree-edges (if enabled).">bfs::non_tree_edges_begin</a>, <a class="el" href="a00003.html#37645ce2ffc6fb95afb56477025a64a8" title="End-iterator for iteration through all non-tree-edges (if enabled).">bfs::non_tree_edges_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e16858479ee2b4980b4dbe73202a9d6"></a><!-- doxytag: member="bfs::store_non_tree_edges" ref="9e16858479ee2b4980b4dbe73202a9d6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bfs::store_non_tree_edges           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the storing of non-tree-edges is enabled. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>iff the storing of non-tree-edges is enabled. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#0c7c3cb97a538907ddd0dc39bd884ffc" title="Iterate through all non-tree-edges (if enabled).">bfs::non_tree_edges_begin</a>, <a class="el" href="a00003.html#37645ce2ffc6fb95afb56477025a64a8" title="End-iterator for iteration through all non-tree-edges (if enabled).">bfs::non_tree_edges_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c7ce0ea2cd8e1932d1da5693d90cf61"></a><!-- doxytag: member="bfs::store_preds" ref="8c7ce0ea2cd8e1932d1da5693d90cf61" args="(bool set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bfs::store_preds           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the storing of predecessors. 
<p>
If enabled for every node the predecessor in the BFS-forest will be stored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>if true predecessors will be stored. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#eff99e4f0142cbb9977503844c0d45c9" title="Father of node n in BFS-forest.">bfs::father</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b73eb7f1fb984331781da890bd45029"></a><!-- doxytag: member="bfs::store_preds" ref="1b73eb7f1fb984331781da890bd45029" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bfs::store_preds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the storing of predecessors is enabled. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>iff the storing of predecessors is enabled. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#eff99e4f0142cbb9977503844c0d45c9" title="Father of node n in BFS-forest.">bfs::father</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a91531970fa0eb1c7e18d5455f54fe9f"></a><!-- doxytag: member="bfs::reached" ref="a91531970fa0eb1c7e18d5455f54fe9f" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bfs::reached           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether node <em>n</em> was reached in BFS. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>node. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>iff <em>n</em> was reached. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ad3b67493e3d936f8ca3d1fe38d72842"></a><!-- doxytag: member="bfs::bfs_num" ref="ad3b67493e3d936f8ca3d1fe38d72842" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bfs::bfs_num           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BFS-number of <em>n</em>. 
<p>
<em>Please</em> <em>note</em> that BFS-number 0 means that this node wasn't reached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>node. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BFS-number of <em>n</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01e0e18c3478faf9ea6b9140c1cc4102"></a><!-- doxytag: member="bfs::operator[]" ref="01e0e18c3478faf9ea6b9140c1cc4102" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bfs::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BFS-number of <em>n</em>. 
<p>
<em>Please</em> <em>note</em> that BFS-number 0 means that this node wasn't reached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>node. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>BFS-number of <em>n</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="db141187b9b6c9fc78089eb87ba19ad4"></a><!-- doxytag: member="bfs::level" ref="db141187b9b6c9fc78089eb87ba19ad4" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bfs::level           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Level-number of node <em>n</em>. 
<p>
<em>Please</em> <em>note</em> that this requires that this option was enabled during last run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>level-number of <em>n</em>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#491515da4eb8efca0be4fef0df350a8e" title="Enables or disables the calculation of level-numbers for each node.">bfs::calc_level</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eff99e4f0142cbb9977503844c0d45c9"></a><!-- doxytag: member="bfs::father" ref="eff99e4f0142cbb9977503844c0d45c9" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> bfs::father           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Father of node <em>n</em> in BFS-forest. 
<p>
If <em>n</em> is a root in the forest or wasn't reached the return value is the invalid node <a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a>.<p>
<em>Please</em> <em>note</em> that this requires that this option was enabled during last run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Father of <em>n</em>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#8c7ce0ea2cd8e1932d1da5693d90cf61" title="Enables or disables the storing of predecessors.">bfs::store_preds</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="50fbe73f807b39845bb2334548c9b8cb"></a><!-- doxytag: member="bfs::tree_edges_begin" ref="50fbe73f807b39845bb2334548c9b8cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#a0b58a03ca2fc32117948ab27a806bd1">tree_edges_iterator</a> bfs::tree_edges_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate through all tree-edges of last BFS. 
<p>
<em>Please</em> <em>note</em> that this edges not always form a tree. In case the graph is not (strongly) connected and the whole <a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a> was scanned, they form a forest.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Start for iteration through all tree-edges. </dd></dl>

</div>
</div><p>
<a class="anchor" name="609773f0e8e94dbdd330d5363c6d610c"></a><!-- doxytag: member="bfs::tree_edges_end" ref="609773f0e8e94dbdd330d5363c6d610c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#a0b58a03ca2fc32117948ab27a806bd1">tree_edges_iterator</a> bfs::tree_edges_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End-iterator for iteration through all tree-edges picked of last BFS. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>End for iteration through all tree-edges. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b83a88f71f210946be3ef212f4c2c37"></a><!-- doxytag: member="bfs::begin" ref="7b83a88f71f210946be3ef212f4c2c37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a> bfs::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate through all (reached) nodes in BFS-Order. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Start for iteration through all nodes in BFS-order. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1a9a095e1e757e8f71ba752bf0e898d"></a><!-- doxytag: member="bfs::end" ref="b1a9a095e1e757e8f71ba752bf0e898d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a> bfs::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End-iterator for iteration through all (reached) nodes in BFS-Order. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>End for iteration through all (reached) nodes </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c7c3cb97a538907ddd0dc39bd884ffc"></a><!-- doxytag: member="bfs::non_tree_edges_begin" ref="0c7c3cb97a538907ddd0dc39bd884ffc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#ecd86c7c1f1086d4b6b11c2a0eb12afe">non_tree_edges_iterator</a> bfs::non_tree_edges_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate through all non-tree-edges (if enabled). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Start for iteration through all non-tree-edges. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#7de47b820fb9532f497660f767c9457f" title="Enables or disables the storing of non-tree-edges.">bfs::store_non_tree_edges</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="37645ce2ffc6fb95afb56477025a64a8"></a><!-- doxytag: member="bfs::non_tree_edges_end" ref="37645ce2ffc6fb95afb56477025a64a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#ecd86c7c1f1086d4b6b11c2a0eb12afe">non_tree_edges_iterator</a> bfs::non_tree_edges_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End-iterator for iteration through all non-tree-edges (if enabled). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>End for iteration through all non-tree-edges. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#7de47b820fb9532f497660f767c9457f" title="Enables or disables the storing of non-tree-edges.">bfs::store_non_tree_edges</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae9df31655e7ef516426dfb99c2de888"></a><!-- doxytag: member="bfs::roots_begin" ref="ae9df31655e7ef516426dfb99c2de888" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#386ac6f3c63e38c3f5263e15c3ab9d01">roots_iterator</a> bfs::roots_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator pointing towards the first root in the BFS-forest. 
<p>
<em>Please</em> <em>note</em> that instead of pointing directly towards the node (i.e. <code>*it</code> is of type <code><a class="el" href="a00020.html" title="A node in a graph.">node</a></code>) the iterator points towards a bfs-iterator, which represents the root (i.e. <code>*it</code> is of type <code>bfs_iterator</code>).<p>
Using this technique makes it possible not only to obtain all the roots in the forest, but also the whole trees associated with each one. This can be achieved because a <code>root_iterator</code> specifies the exact position of the root in the BFS-ordering and by definition of BFS all the descendents of the root, i.e. the whole tree below, will come later in BFS, such that by incrementing the <code>bfs_iterator</code> a <code>roots_iterator</code> refers to, one can traverse the whole tree with this given root.<p>
Of course if the root isn't the last node in the BFS-forest all following trees also will be traversed. But since the first node of such a tree, that will be discovered, is its root, the successor of the <code>roots_iterator</code> can be used as end-iterator.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Start for iteration through all roots in BFS-forest. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="31e77fd48aed1902d488a54f2f0ef6f8"></a><!-- doxytag: member="bfs::roots_end" ref="31e77fd48aed1902d488a54f2f0ef6f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html#386ac6f3c63e38c3f5263e15c3ab9d01">roots_iterator</a> bfs::roots_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator pointing to the end of all roots. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>End for iteration through all roots in BFS-forest. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="50ca0ee41753b59ed7adfe9f60adf1e4"></a><!-- doxytag: member="bfs::number_of_reached_nodes" ref="50ca0ee41753b59ed7adfe9f60adf1e4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bfs::number_of_reached_nodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of nodes reached in last BFS. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of reached nodes. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9af608a9b2d570a8688498bc3c53d7f"></a><!-- doxytag: member="bfs::init_handler" ref="b9af608a9b2d570a8688498bc3c53d7f" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::init_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called at the start of BFS. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d99b9aeb177a8a2e0ce1c3673082cddf"></a><!-- doxytag: member="bfs::end_handler" ref="d99b9aeb177a8a2e0ce1c3673082cddf" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::end_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called right before the end of BFS. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3f161fe9f45e0a69892f355a889c3516"></a><!-- doxytag: member="bfs::popped_node_handler" ref="3f161fe9f45e0a69892f355a889c3516" args="(graph &amp;G, node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::popped_node_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called after the node <em>n</em> was taken out of the queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>node taken out of the queue. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="db6604080f3376e9713e35cd9d7d8943"></a><!-- doxytag: member="bfs::finished_node_handler" ref="db6604080f3376e9713e35cd9d7d8943" args="(graph &amp;G, node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::finished_node_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when finished with the node <em>n</em>. 
<p>
A node is finished after all its neighbors have been visited.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>finished node. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e45c8fe90e54bffe18b308868ccc111"></a><!-- doxytag: member="bfs::unused_node_handler" ref="0e45c8fe90e54bffe18b308868ccc111" args="(graph &amp;G, node &amp;n, node &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::unused_node_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when an unused node <em>n</em> was discovered. 
<p>
This means that the actual node's <em>f</em> neighbor <em>n</em> was not previously discovered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>unused node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>actual node. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d2cbb1e9c36f561da0c91fd142296f2a"></a><!-- doxytag: member="bfs::used_node_handler" ref="d2cbb1e9c36f561da0c91fd142296f2a" args="(graph &amp;G, node &amp;n, node &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::used_node_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when an used node <em>n</em> was found. 
<p>
This means that the actual node's (<em>f</em>) neighbor <em>n</em> has already been discovered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>used node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>actual node. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4f33f10121240390a5a50b5efc16c1f5"></a><!-- doxytag: member="bfs::new_start_handler" ref="4f33f10121240390a5a50b5efc16c1f5" args="(graph &amp;G, node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bfs::new_start_handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when BFS is started with start-node <em>n</em>. 
<p>
This is particularly useful when BFS was invoked with the <code>scan_whole_graph</code> option.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>graph for which BFS was invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>start-node. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="35b0acd44887615142fd5f2fc6197452"></a><!-- doxytag: member="bfs::bfs_order" ref="35b0acd44887615142fd5f2fc6197452" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00020.html">node</a>&gt; <a class="el" href="a00003.html#35b0acd44887615142fd5f2fc6197452">bfs::bfs_order</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of nodes in BFS-order. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#7b83a88f71f210946be3ef212f4c2c37" title="Iterate through all (reached) nodes in BFS-Order.">bfs::begin</a>, <a class="el" href="a00003.html#b1a9a095e1e757e8f71ba752bf0e898d" title="End-iterator for iteration through all (reached) nodes in BFS-Order.">bfs::end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a259f09ada9928cda41bcb540f685e80"></a><!-- doxytag: member="bfs::tree" ref="a259f09ada9928cda41bcb540f685e80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00010.html">edge</a>&gt; <a class="el" href="a00003.html#a259f09ada9928cda41bcb540f685e80">bfs::tree</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of all edges of the BFS-tree. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#50fbe73f807b39845bb2334548c9b8cb" title="Iterate through all tree-edges of last BFS.">bfs::tree_edges_begin</a>, <a class="el" href="a00003.html#609773f0e8e94dbdd330d5363c6d610c" title="End-iterator for iteration through all tree-edges picked of last BFS.">bfs::tree_edges_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="79d19028002766f7992fe94689217f99"></a><!-- doxytag: member="bfs::roots" ref="79d19028002766f7992fe94689217f99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00003.html#cafce54954100cc7bc9f80eb318a7bee">bfs_iterator</a>&gt; <a class="el" href="a00003.html#79d19028002766f7992fe94689217f99">bfs::roots</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of all roots of the BFS-tree. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#ae9df31655e7ef516426dfb99c2de888" title="Iterator pointing towards the first root in the BFS-forest.">bfs::roots_begin</a>, <a class="el" href="a00003.html#31e77fd48aed1902d488a54f2f0ef6f8" title="Iterator pointing to the end of all roots.">bfs::roots_end</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c08fbcc90d71f1cbdd03a1cdaa9dc99"></a><!-- doxytag: member="bfs::whole_graph" ref="6c08fbcc90d71f1cbdd03a1cdaa9dc99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00003.html#6c08fbcc90d71f1cbdd03a1cdaa9dc99">bfs::whole_graph</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores whether whole graph will be scanned. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#25fc51b1bfbbdd3afefe0a84c1bd2f6b" title="Enables or disables scanning of the whole graph.">bfs::scan_whole_graph</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2ab561d9e60a9fc2e25b02d1f807f96"></a><!-- doxytag: member="bfs::start" ref="f2ab561d9e60a9fc2e25b02d1f807f96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> <a class="el" href="a00003.html#f2ab561d9e60a9fc2e25b02d1f807f96">bfs::start</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores start node. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html" title="Breadth-First-Search (BFS) algorithm.">bfs</a>:<a class="el" href="a00003.html#23e2981c2ee617a6e12a8833d2db6210" title="Sets start-node for BFS.">start_node</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab92e9d128612c28324aafe4750dbc84"></a><!-- doxytag: member="bfs::level_number" ref="ab92e9d128612c28324aafe4750dbc84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">node_map</a>&lt;int&gt;* <a class="el" href="a00003.html#ab92e9d128612c28324aafe4750dbc84">bfs::level_number</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores level number of each node (if enabled). 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#491515da4eb8efca0be4fef0df350a8e" title="Enables or disables the calculation of level-numbers for each node.">bfs::calc_level</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a6783e3e2ac4235403b37df3ee3ee968"></a><!-- doxytag: member="bfs::non_tree" ref="a6783e3e2ac4235403b37df3ee3ee968" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="a00010.html">edge</a>&gt;* <a class="el" href="a00003.html#a6783e3e2ac4235403b37df3ee3ee968">bfs::non_tree</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of non-tree edges (if enabled). 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#7de47b820fb9532f497660f767c9457f" title="Enables or disables the storing of non-tree-edges.">bfs::store_non_tree_edges</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3bac5ed333bb78a30a67099c3b94aa0c"></a><!-- doxytag: member="bfs::preds" ref="3bac5ed333bb78a30a67099c3b94aa0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00021.html">node_map</a>&lt;<a class="el" href="a00020.html">node</a>&gt;* <a class="el" href="a00003.html#3bac5ed333bb78a30a67099c3b94aa0c">bfs::preds</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores father of each node (if enabled). 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00003.html#8c7ce0ea2cd8e1932d1da5693d90cf61" title="Enables or disables the storing of predecessors.">bfs::store_preds</a> </dd></dl>

</div>
</div><p>
    <p class="links">
      <a href="http://www.uni-passau.de/">University of Passau</a>
      &nbsp;-&nbsp;
      <a href="http://www.fmi.uni-passau.de/">FMI</a>
      &nbsp;-&nbsp;
      <a href="http://www.fmi.uni-passau.de/fmi/lehrstuehle/brandenburg/">Theoretical
	Computer Science</a>
    </p>
  <div class="copyright">
      Design &copy; 2002, 2003 <a href="mailto:raitner@fmi.uni-passau.de">Marcus Raitner</a>,  University of Passau 
  </div>
</body>
</html>
