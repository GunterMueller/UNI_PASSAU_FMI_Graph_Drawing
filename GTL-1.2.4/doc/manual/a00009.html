<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
      <title>GTL - Graph Template Library: dijkstra Class Reference</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <p class="links">  
      <a href="../index.html">Home</a> |
      Documentation |
      <a href="../register.html">Download</a> |
      <a href="../platforms.html">Platforms</a> |
      <a href="../refer.html">Projects</a> |      
      <a href="../lists.html">Mailing Lists</a> |
      <a href="../history.html">Version History</a>
    </p>

<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>dijkstra Class Reference</h1><!-- doxytag: class="dijkstra" --><!-- doxytag: inherits="algorithm" -->Dijkstra's Algorithm for computing single source shortest path.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for dijkstra:</div>
<div class="dynsection">
<p><center><img src="a00136.gif" border="0" usemap="#a00137" alt="Inheritance graph"></center>
<map name="a00137">
<area shape="rect" href="a00001.html" title="Abstract baseclass for all algoritm&#45;classes." alt="" coords="5,7,83,31"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for dijkstra:</div>
<div class="dynsection">
<p><center><img src="a00138.gif" border="0" usemap="#a00139" alt="Collaboration graph"></center>
<map name="a00139">
<area shape="rect" href="a00001.html" title="Abstract baseclass for all algoritm&#45;classes." alt="" coords="501,5,579,29"><area shape="rect" href="a00020.html" title="A node in a graph." alt="" coords="515,92,565,116"><area shape="rect" title="s\nt" alt="" coords="563,97,571,105"><area shape="rect" title="s\nt" alt="" coords="844,209,852,217"><area shape="rect" title="int_node" alt="" coords="511,92,519,100"><area shape="rect" title="int_node" alt="" coords="563,92,571,100"><area shape="rect" href="a00021.html" title="node_map\&lt; int \&gt;" alt="" coords="479,140,601,164"><area shape="rect" title="mark" alt="" coords="597,151,605,159"><area shape="rect" title="mark" alt="" coords="831,209,839,217"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, int, graph, allocator\&lt; int \&gt; \&gt;" alt="" coords="61,140,344,164"><area shape="rect" href="a00021.html" title="node_map\&lt; edge \&gt;" alt="" coords="471,188,609,212"><area shape="rect" title="pred" alt="" coords="605,201,613,209"><area shape="rect" title="pred" alt="" coords="816,219,824,227"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, edge, graph, allocator\&lt; edge \&gt; \&gt;" alt="" coords="45,188,360,212"><area shape="rect" href="a00021.html" title="node_map\&lt; list\&lt; node \&gt; \&gt;" alt="" coords="451,236,629,260"><area shape="rect" title="shortest_path_node_list" alt="" coords="625,251,633,259"><area shape="rect" title="shortest_path_node_list" alt="" coords="816,235,824,243"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, list\&lt; node \&gt;, graph, allocator\&lt; list\&lt; node \&gt; \&gt; \&gt;" alt="" coords="5,236,400,260"><area shape="rect" href="a00011.html" title="edge_map\&lt; double \&gt;" alt="" coords="465,284,615,308"><area shape="rect" title="weight" alt="" coords="611,299,619,307"><area shape="rect" title="weight" alt="" coords="837,235,845,243"><area shape="rect" href="a00019.html" title="ne_map\&lt; edge, double, graph, allocator\&lt; double \&gt; \&gt;" alt="" coords="36,284,369,308"><area shape="rect" href="a00021.html" title="node_map\&lt; list\&lt; edge \&gt; \&gt;" alt="" coords="451,332,629,356"><area shape="rect" title="shortest_path_edge_list" alt="" coords="623,353,631,361"><area shape="rect" title="shortest_path_edge_list" alt="" coords="845,235,853,243"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, list\&lt; edge \&gt;, graph, allocator\&lt; list\&lt; edge \&gt; \&gt; \&gt;" alt="" coords="5,332,400,356"><area shape="rect" href="a00021.html" title="node_map\&lt; double \&gt;" alt="" coords="465,380,615,404"><area shape="rect" title="dist" alt="" coords="591,401,599,409"><area shape="rect" title="dist" alt="" coords="845,235,853,243"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, double, graph, allocator\&lt; double \&gt; \&gt;" alt="" coords="36,380,369,404"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00140.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5062e9a8339848666efcf2143c4c1881"></a><!-- doxytag: member="dijkstra::shortest_path_node_iterator" ref="5062e9a8339848666efcf2143c4c1881" args="" -->
typedef list&lt; <a class="el" href="a00020.html">node</a> &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#5062e9a8339848666efcf2143c4c1881">shortest_path_node_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator type for traversing nodes on one shortest path. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d35d95d4ed7a4202a5d048a63aa115b9"></a><!-- doxytag: member="dijkstra::shortest_path_edge_iterator" ref="d35d95d4ed7a4202a5d048a63aa115b9" args="" -->
typedef list&lt; <a class="el" href="a00010.html">edge</a> &gt;<br>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#d35d95d4ed7a4202a5d048a63aa115b9">shortest_path_edge_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator type for traversing edges on one shortest path. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#64a1fcb9cca32ff932b9b98a08cff106">dijkstra</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#64a1fcb9cca32ff932b9b98a08cff106"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#3840ee3f3f49662f31e9bfab46fd0d12">~dijkstra</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#3840ee3f3f49662f31e9bfab46fd0d12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#9689f2628f76ddb3747ea18c91bd7041">source</a> (const <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets source node.  <a href="#9689f2628f76ddb3747ea18c91bd7041"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#1e9971d767046306574551a461aa2238">target</a> (const <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets target node.  <a href="#1e9971d767046306574551a461aa2238"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#92f4394b757f6ffcb372535114a6cbf6">weights</a> (const <a class="el" href="a00011.html">edge_map</a>&lt; double &gt; &amp;weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets weights of the edges.  <a href="#92f4394b757f6ffcb372535114a6cbf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#f79383dbbb6b737afcefd8e32350192d">store_preds</a> (bool set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the storing of predecessors.  <a href="#f79383dbbb6b737afcefd8e32350192d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#fb4aff7134caa15dcce88668c54899aa">check</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the preconditions for Dijkstra are satisfied.  <a href="#fb4aff7134caa15dcce88668c54899aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#7b30f3d8ad42baae27989bc14befe0d0">run</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs shortest path algorithm on <code>G</code>.  <a href="#7b30f3d8ad42baae27989bc14befe0d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a91b7c49f9ca6b40a4b95747238fabdc">source</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns source node.  <a href="#a91b7c49f9ca6b40a4b95747238fabdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#65fe009e1b882ccebfd62b876d76223d">target</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns target node if set, <code><a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a></code> else.  <a href="#65fe009e1b882ccebfd62b876d76223d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a099fc1273e1a7f5902cfe02d5ddabdf">store_preds</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the storing of predecessors is enabled.  <a href="#a099fc1273e1a7f5902cfe02d5ddabdf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#eda156a71bc3eacfb9192e79e5581fef">reached</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether <code>n</code> is reachable from source node.  <a href="#eda156a71bc3eacfb9192e79e5581fef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#d2195288151f7b95bad96f186faef815">distance</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the distance from source node to node <code>n</code>.  <a href="#d2195288151f7b95bad96f186faef815"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#4885d97269ef954ea17047ebf8a697ab">predecessor_node</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predecessor node of node <code>n</code> on the shortest path from the source node.  <a href="#4885d97269ef954ea17047ebf8a697ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html">edge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#f33f8c44fbe24f40e79c725b782b97dc">predecessor_edge</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predecessor edge of node <code>n</code> on the shortest path from the source node.  <a href="#f33f8c44fbe24f40e79c725b782b97dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00009.html#5062e9a8339848666efcf2143c4c1881">shortest_path_node_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#fb6b11117d954b6f83ef03735f47a7e3">shortest_path_nodes_begin</a> (const <a class="el" href="a00020.html">node</a> &amp;dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the beginning (to the source node) of a shortest node path to node <code>dest</code>.  <a href="#fb6b11117d954b6f83ef03735f47a7e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00009.html#5062e9a8339848666efcf2143c4c1881">shortest_path_node_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#5e7c8dd055ab5e397b3ba22292d07024">shortest_path_nodes_end</a> (const <a class="el" href="a00020.html">node</a> &amp;dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator one after the end (one after node <code>dest</code>) of a shortest node path to node <code>dest</code>.  <a href="#5e7c8dd055ab5e397b3ba22292d07024"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00009.html#d35d95d4ed7a4202a5d048a63aa115b9">shortest_path_edge_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#c2bc10ad8c2df1a1db40dc6ee8af1089">shortest_path_edges_begin</a> (const <a class="el" href="a00020.html">node</a> &amp;dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the beginning edge of a shortest edge path to node <code>dest</code>.  <a href="#c2bc10ad8c2df1a1db40dc6ee8af1089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00009.html#d35d95d4ed7a4202a5d048a63aa115b9">shortest_path_edge_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#df4b143b1c583871819028a734a1ab01">shortest_path_edges_end</a> (const <a class="el" href="a00020.html">node</a> &amp;dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator one after the end of a shortest edge path to node <code>dest</code>.  <a href="#df4b143b1c583871819028a734a1ab01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#16f9249e8cce25cbd0a3297fc8fa9a44">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets Dijkstra's <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a>.  <a href="#16f9249e8cce25cbd0a3297fc8fa9a44"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Dijkstra's Algorithm for computing single source shortest path. 
<p>
This class implements Dijkstra's <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a> for computing single source shortest path in <img class="formulaInl" alt="$\mathcal{O}((|V| + |E|) log |V|)$" src="form_0.png"> worst case.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html" title="Bellman Ford algorithm.">bellman_ford</a></dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Christian Bachmaier <a href="mailto:chris@infosun.fmi.uni-passau.de">chris@infosun.fmi.uni-passau.de</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="64a1fcb9cca32ff932b9b98a08cff106"></a><!-- doxytag: member="dijkstra::dijkstra" ref="64a1fcb9cca32ff932b9b98a08cff106" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dijkstra::dijkstra           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
Enables only the calculation of shortest paths.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#b79e1ddec2f2afdf4b36b10724db8b15" title="Creates an algorithm object.">algorithm::algorithm</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3840ee3f3f49662f31e9bfab46fd0d12"></a><!-- doxytag: member="dijkstra::~dijkstra" ref="3840ee3f3f49662f31e9bfab46fd0d12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual dijkstra::~dijkstra           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#dca9b1e7fa3afd914519a9dbb44e9fd5" title="Destroys the algorithm object.">algorithm::~algorithm</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9689f2628f76ddb3747ea18c91bd7041"></a><!-- doxytag: member="dijkstra::source" ref="9689f2628f76ddb3747ea18c91bd7041" args="(const node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra::source           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets source node. 
<p>
The default source is the invalid node (<a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a>), in this case an arbitrary node is chosen and stored when this <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a> is run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>source <a class="el" href="a00020.html" title="A node in a graph.">node</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1e9971d767046306574551a461aa2238"></a><!-- doxytag: member="dijkstra::target" ref="1e9971d767046306574551a461aa2238" args="(const node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra::target           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets target node. 
<p>
If a target is set with this method the algorithm stops if a shortest distance to <code>n</code> is found. Ohterwise shortest paths are computed from source to any node in the graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>target <a class="el" href="a00020.html" title="A node in a graph.">node</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92f4394b757f6ffcb372535114a6cbf6"></a><!-- doxytag: member="dijkstra::weights" ref="92f4394b757f6ffcb372535114a6cbf6" args="(const edge_map&lt; double &gt; &amp;weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra::weights           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00011.html">edge_map</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weight</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets weights of the edges. 
<p>
This method <b>must</b> be called before check run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>weights of the edges </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f79383dbbb6b737afcefd8e32350192d"></a><!-- doxytag: member="dijkstra::store_preds" ref="f79383dbbb6b737afcefd8e32350192d" args="(bool set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra::store_preds           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the storing of predecessors. 
<p>
If enabled for every node the predecessor on the shortest path from will be stored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td><code>true</code> if predecessors should be stored</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00009.html#4885d97269ef954ea17047ebf8a697ab" title="Predecessor node of node n on the shortest path from the source node.">dijkstra::predecessor_node</a> <p>
<a class="el" href="a00009.html#f33f8c44fbe24f40e79c725b782b97dc" title="Predecessor edge of node n on the shortest path from the source node.">dijkstra::predecessor_edge</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb4aff7134caa15dcce88668c54899aa"></a><!-- doxytag: member="dijkstra::check" ref="fb4aff7134caa15dcce88668c54899aa" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int dijkstra::check           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the preconditions for Dijkstra are satisfied. 
<p>
Necessary preconditions are:<ul>
<li>the weights of the edges are set</li><li>the graph <code>G</code> has at least one node</li><li>all edge weights must be <img class="formulaInl" alt="$\ge 0$" src="form_1.png"></li><li>the source node and (if set) target node must be found in <code>G</code> </li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td><a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a></em>&nbsp;</td><td>if algorithm can be applied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67106fcf574690bbd6cf710837a169510dd7">algorithm::GTL_ERROR</a></em>&nbsp;</td><td>otherwise</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00009.html#9689f2628f76ddb3747ea18c91bd7041" title="Sets source node.">dijkstra::source</a> <p>
<a class="el" href="a00009.html#92f4394b757f6ffcb372535114a6cbf6" title="Sets weights of the edges.">dijkstra::weights</a> <p>
<a class="el" href="a00001.html#76361fb03ad1cf643affc51821e43bed" title="Checks whether all preconditions are satisfied.">algorithm::check</a> </dd></dl>

<p>Implements <a class="el" href="a00001.html#76361fb03ad1cf643affc51821e43bed">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="7b30f3d8ad42baae27989bc14befe0d0"></a><!-- doxytag: member="dijkstra::run" ref="7b30f3d8ad42baae27989bc14befe0d0" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dijkstra::run           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs shortest path algorithm on <code>G</code>. 
<p>
This should return always <a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a>. The return value only tracks errors that might occur. Afterwards the result of the test can be accessed via access methods.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td><a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a></em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67106fcf574690bbd6cf710837a169510dd7">algorithm::GTL_ERROR</a></em>&nbsp;</td><td>otherwise</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#734b189509a8d6b56b65f8ff772d43ca" title="Applies algorithm to graph g.">algorithm::run</a> </dd></dl>

<p>Implements <a class="el" href="a00001.html#734b189509a8d6b56b65f8ff772d43ca">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="a91b7c49f9ca6b40a4b95747238fabdc"></a><!-- doxytag: member="dijkstra::source" ref="a91b7c49f9ca6b40a4b95747238fabdc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> dijkstra::source           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns source node. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>source node </dd></dl>

</div>
</div><p>
<a class="anchor" name="65fe009e1b882ccebfd62b876d76223d"></a><!-- doxytag: member="dijkstra::target" ref="65fe009e1b882ccebfd62b876d76223d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> dijkstra::target           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns target node if set, <code><a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a></code> else. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>target node </dd></dl>

</div>
</div><p>
<a class="anchor" name="a099fc1273e1a7f5902cfe02d5ddabdf"></a><!-- doxytag: member="dijkstra::store_preds" ref="a099fc1273e1a7f5902cfe02d5ddabdf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dijkstra::store_preds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the storing of predecessors is enabled. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> iff the storing of predecessors is enabled</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>dijkstra::predecessor </dd></dl>

</div>
</div><p>
<a class="anchor" name="eda156a71bc3eacfb9192e79e5581fef"></a><!-- doxytag: member="dijkstra::reached" ref="eda156a71bc3eacfb9192e79e5581fef" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dijkstra::reached           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether <code>n</code> is reachable from source node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> iff <code>n</code> was reached from source </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2195288151f7b95bad96f186faef815"></a><!-- doxytag: member="dijkstra::distance" ref="d2195288151f7b95bad96f186faef815" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dijkstra::distance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the distance from source node to node <code>n</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>distance if <code>n</code> is <a class="el" href="a00009.html#eda156a71bc3eacfb9192e79e5581fef" title="Returns whether n is reachable from source node.">dijkstra::reached</a>, <code>-1.0</code> else </dd></dl>

</div>
</div><p>
<a class="anchor" name="4885d97269ef954ea17047ebf8a697ab"></a><!-- doxytag: member="dijkstra::predecessor_node" ref="4885d97269ef954ea17047ebf8a697ab" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> dijkstra::predecessor_node           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Predecessor node of node <code>n</code> on the shortest path from the source node. 
<p>
If <code>n</code> is a root or wasn't reached the return value is the invalid node <a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>predecessor node of <code>n</code> </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00009.html#f79383dbbb6b737afcefd8e32350192d" title="Enables or disables the storing of predecessors.">dijkstra::store_preds</a> <p>
<a class="el" href="a00009.html#f33f8c44fbe24f40e79c725b782b97dc" title="Predecessor edge of node n on the shortest path from the source node.">dijkstra::predecessor_edge</a></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The method requires that predecessor calculation option was enabled during last run. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f33f8c44fbe24f40e79c725b782b97dc"></a><!-- doxytag: member="dijkstra::predecessor_edge" ref="f33f8c44fbe24f40e79c725b782b97dc" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">edge</a> dijkstra::predecessor_edge           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Predecessor edge of node <code>n</code> on the shortest path from the source node. 
<p>
If <code>n</code> is a root or wasn't reached the return value is the invalid edge <a class="el" href="a00010.html#c8047a0d7c1e08a4063be409c6fd0a88">edge::edge()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>predecessor edge of <code>n</code> </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00009.html#f79383dbbb6b737afcefd8e32350192d" title="Enables or disables the storing of predecessors.">dijkstra::store_preds</a> <p>
<a class="el" href="a00009.html#4885d97269ef954ea17047ebf8a697ab" title="Predecessor node of node n on the shortest path from the source node.">dijkstra::predecessor_node</a></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The method requires that predecessor calculation option was enabled during last run. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb6b11117d954b6f83ef03735f47a7e3"></a><!-- doxytag: member="dijkstra::shortest_path_nodes_begin" ref="fb6b11117d954b6f83ef03735f47a7e3" args="(const node &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html#5062e9a8339848666efcf2143c4c1881">shortest_path_node_iterator</a> dijkstra::shortest_path_nodes_begin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator to the beginning (to the source node) of a shortest node path to node <code>dest</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>target node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>beginning node iterator of a shortest path</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The method requires that predecessor calculation option was enabled during last run. If this method is called on the shortest path to <code>dest</code> for the first time (before <a class="el" href="a00009.html#5e7c8dd055ab5e397b3ba22292d07024" title="Returns an iterator one after the end (one after node dest) of a shortest node path...">dijkstra::shortest_path_nodes_end</a>) it needs <img class="formulaInl" alt="$\mathcal{O}(\mbox{length of this path})$" src="form_2.png"> time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e7c8dd055ab5e397b3ba22292d07024"></a><!-- doxytag: member="dijkstra::shortest_path_nodes_end" ref="5e7c8dd055ab5e397b3ba22292d07024" args="(const node &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html#5062e9a8339848666efcf2143c4c1881">shortest_path_node_iterator</a> dijkstra::shortest_path_nodes_end           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator one after the end (one after node <code>dest</code>) of a shortest node path to node <code>dest</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>target node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>shortest path end node iterator</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The method requires that predecessor calculation option was enabled during last run. If this method is called on the shortest path to <code>dest</code> for the first time (before <a class="el" href="a00009.html#fb6b11117d954b6f83ef03735f47a7e3" title="Returns an iterator to the beginning (to the source node) of a shortest node path...">dijkstra::shortest_path_nodes_begin</a>) it needs <img class="formulaInl" alt="$\mathcal{O}(\mbox{length of this path})$" src="form_2.png"> time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c2bc10ad8c2df1a1db40dc6ee8af1089"></a><!-- doxytag: member="dijkstra::shortest_path_edges_begin" ref="c2bc10ad8c2df1a1db40dc6ee8af1089" args="(const node &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html#d35d95d4ed7a4202a5d048a63aa115b9">shortest_path_edge_iterator</a> dijkstra::shortest_path_edges_begin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator to the beginning edge of a shortest edge path to node <code>dest</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>target node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>beginning edge iterator of a shortest path</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The method requires that predecessor calculation option was enabled during last run. If this method is called on the shortest path to <code>dest</code> for the first time (before <a class="el" href="a00009.html#df4b143b1c583871819028a734a1ab01" title="Returns an iterator one after the end of a shortest edge path to node dest.">dijkstra::shortest_path_edges_end</a>) it needs <img class="formulaInl" alt="$\mathcal{O}(\mbox{length of this path})$" src="form_2.png"> time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="df4b143b1c583871819028a734a1ab01"></a><!-- doxytag: member="dijkstra::shortest_path_edges_end" ref="df4b143b1c583871819028a734a1ab01" args="(const node &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html#d35d95d4ed7a4202a5d048a63aa115b9">shortest_path_edge_iterator</a> dijkstra::shortest_path_edges_end           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator one after the end of a shortest edge path to node <code>dest</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>target node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>shortest path end edge iterator</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The method requires that predecessor calculation option was enabled during last run. If this method is called on the shortest path to <code>dest</code> for the first time (before <a class="el" href="a00009.html#c2bc10ad8c2df1a1db40dc6ee8af1089" title="Returns an iterator to the beginning edge of a shortest edge path to node dest.">dijkstra::shortest_path_edges_begin</a>) it needs <img class="formulaInl" alt="$\mathcal{O}(\mbox{length of this path})$" src="form_2.png"> time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="16f9249e8cce25cbd0a3297fc8fa9a44"></a><!-- doxytag: member="dijkstra::reset" ref="16f9249e8cce25cbd0a3297fc8fa9a44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dijkstra::reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets Dijkstra's <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a>. 
<p>
It prepares the <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a> to be applied again, possibly to another <a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The weights are not reset. You can apply this algorithms</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#21aba63d066ae7897de6ca7d8425c408" title="Resets algorithm.">algorithm::reset</a> </dd></dl>

<p>Implements <a class="el" href="a00001.html#21aba63d066ae7897de6ca7d8425c408">algorithm</a>.</p>

</div>
</div><p>
    <p class="links">
      <a href="http://www.uni-passau.de/">University of Passau</a>
      &nbsp;-&nbsp;
      <a href="http://www.fmi.uni-passau.de/">FMI</a>
      &nbsp;-&nbsp;
      <a href="http://www.fmi.uni-passau.de/fmi/lehrstuehle/brandenburg/">Theoretical
	Computer Science</a>
    </p>
  <div class="copyright">
      Design &copy; 2002, 2003 <a href="mailto:raitner@fmi.uni-passau.de">Marcus Raitner</a>,  University of Passau 
  </div>
</body>
</html>
