<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
      <title>GTL - Graph Template Library: bellman_ford Class Reference</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <p class="links">  
      <a href="../index.html">Home</a> |
      Documentation |
      <a href="../register.html">Download</a> |
      <a href="../platforms.html">Platforms</a> |
      <a href="../refer.html">Projects</a> |      
      <a href="../lists.html">Mailing Lists</a> |
      <a href="../history.html">Version History</a>
    </p>

<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>bellman_ford Class Reference</h1><!-- doxytag: class="bellman_ford" --><!-- doxytag: inherits="algorithm" -->Bellman Ford algorithm.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for bellman_ford:</div>
<div class="dynsection">
<p><center><img src="a00105.gif" border="0" usemap="#a00106" alt="Inheritance graph"></center>
<map name="a00106">
<area shape="rect" href="a00001.html" title="Abstract baseclass for all algoritm&#45;classes." alt="" coords="16,7,93,31"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for bellman_ford:</div>
<div class="dynsection">
<p><center><img src="a00107.gif" border="0" usemap="#a00108" alt="Collaboration graph"></center>
<map name="a00108">
<area shape="rect" href="a00001.html" title="Abstract baseclass for all algoritm&#45;classes." alt="" coords="428,5,505,29"><area shape="rect" href="a00020.html" title="A node in a graph." alt="" coords="441,92,492,116"><area shape="rect" title="s" alt="" coords="489,108,497,116"><area shape="rect" title="s" alt="" coords="644,161,652,169"><area shape="rect" title="int_node" alt="" coords="437,91,445,99"><area shape="rect" title="int_node" alt="" coords="489,89,497,97"><area shape="rect" href="a00021.html" title="node_map\&lt; edge \&gt;" alt="" coords="397,140,536,164"><area shape="rect" title="preds" alt="" coords="532,156,540,164"><area shape="rect" title="preds" alt="" coords="621,167,629,175"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, edge, graph, allocator\&lt; edge \&gt; \&gt;" alt="" coords="16,140,331,164"><area shape="rect" href="a00011.html" title="edge_map\&lt; double \&gt;" alt="" coords="392,188,541,212"><area shape="rect" title="w" alt="" coords="537,199,545,207"><area shape="rect" title="w" alt="" coords="629,187,637,195"><area shape="rect" href="a00019.html" title="ne_map\&lt; edge, double, graph, allocator\&lt; double \&gt; \&gt;" alt="" coords="7,188,340,212"><area shape="rect" href="a00021.html" title="node_map\&lt; bool \&gt;" alt="" coords="400,236,533,260"><area shape="rect" title="inf" alt="" coords="531,236,539,244"><area shape="rect" title="inf" alt="" coords="653,187,661,195"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, bool, graph, allocator\&lt; bool \&gt; \&gt;" alt="" coords="21,236,325,260"><area shape="rect" href="a00021.html" title="node_map\&lt; double \&gt;" alt="" coords="392,284,541,308"><area shape="rect" title="d" alt="" coords="528,280,536,288"><area shape="rect" title="d" alt="" coords="661,187,669,195"><area shape="rect" href="a00019.html" title="ne_map\&lt; node, double, graph, allocator\&lt; double \&gt; \&gt;" alt="" coords="7,284,340,308"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00109.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4bad319b62ea978b6d008cec9e94b4bc"></a><!-- doxytag: member="bellman_ford::bellman_ford" ref="4bad319b62ea978b6d008cec9e94b4bc" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#4bad319b62ea978b6d008cec9e94b4bc">bellman_ford</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8fce4fdf5ad4d7ee2355c08816cc4f67"></a><!-- doxytag: member="bellman_ford::~bellman_ford" ref="8fce4fdf5ad4d7ee2355c08816cc4f67" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#8fce4fdf5ad4d7ee2355c08816cc4f67">~bellman_ford</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#9da2fb7d20ef1f726ee935474302d80b">check</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the preconditions for Bellman Ford are satisfied.  <a href="#9da2fb7d20ef1f726ee935474302d80b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#226308389f3c36dfc02768c09f777a3b">run</a> (<a class="el" href="a00014.html">graph</a> &amp;G)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies algorithm to graph g.  <a href="#226308389f3c36dfc02768c09f777a3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#7d28afa62ce8068c4d0f2d1f96136fd6">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a>.  <a href="#7d28afa62ce8068c4d0f2d1f96136fd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#98cad540fd2d211c1ba44bb6fa8416f3">source</a> (const <a class="el" href="a00020.html">node</a> &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets source.  <a href="#98cad540fd2d211c1ba44bb6fa8416f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#d0cf03b1e57fc0e96ce46f772519e5b2">source</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns source.  <a href="#d0cf03b1e57fc0e96ce46f772519e5b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#9e276cc9f30c2e608d320db4a08b2a74">weights</a> (const <a class="el" href="a00011.html">edge_map</a>&lt; double &gt; &amp;weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets weights of the edges.  <a href="#9e276cc9f30c2e608d320db4a08b2a74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac87169a3cf4f95477ce215a0cb7a12b">store_preds</a> (bool set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the storing of predecessors.  <a href="#ac87169a3cf4f95477ce215a0cb7a12b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#46385105a5c73d364cc92276ddd8daa1">store_preds</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the storing of predecessors is enabled.  <a href="#46385105a5c73d364cc92276ddd8daa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#48fd2ed9748bdafeb61e5bb296ec67c6">reached</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether is reachable from source.  <a href="#48fd2ed9748bdafeb61e5bb296ec67c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#30203c9433e4fb628e6d5d86e2c81d5c">distance</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the distance from source to <em>n</em>.  <a href="#30203c9433e4fb628e6d5d86e2c81d5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html">edge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ec75a9280a8e108b59f5f0294e4bdff0">predecessor_edge</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00010.html" title="An edge in a graph.">edge</a> to predecessor of node <em>n</em> on the shortest path from source  <a href="#ec75a9280a8e108b59f5f0294e4bdff0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00020.html">node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#3122381284e811ef02b7061d383eecb7">predecessor_node</a> (const <a class="el" href="a00020.html">node</a> &amp;n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">predecessor of node <em>n</em> on the shortest path from source  <a href="#3122381284e811ef02b7061d383eecb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2dd5b35844eeb4ca3e57f42d57975ebe"></a><!-- doxytag: member="bellman_ford::negative_cycle" ref="2dd5b35844eeb4ca3e57f42d57975ebe" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#2dd5b35844eeb4ca3e57f42d57975ebe">negative_cycle</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether there is a cycle with negative weight. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Bellman Ford algorithm. 
<p>
<dl class="rcs" compact><dt><b>Date</b></dt><dd></dd></dl>
<dl class="rcs" compact><dt><b>Revision</b></dt><dd></dd></dl>
<p>
Implementation of the single source shortest path due to Bellman and Ford. Unlike Dijkstra's SSSP algorithm this one allows negative <a class="el" href="a00010.html" title="An edge in a graph.">edge</a> weights, as long as there are no cycles with negative weight. If there are negative cycles this implementation finds them. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9da2fb7d20ef1f726ee935474302d80b"></a><!-- doxytag: member="bellman_ford::check" ref="9da2fb7d20ef1f726ee935474302d80b" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bellman_ford::check           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the preconditions for Bellman Ford are satisfied. 
<p>
The Precondition are that the weights of the edges have been set and that the <a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a> has at least one <a class="el" href="a00020.html" title="A node in a graph.">node</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td><a class="el" href="a00014.html" title="A directed or undirected graph.">graph</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a></em>&nbsp;</td><td>if algorithm can be applied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67106fcf574690bbd6cf710837a169510dd7">algorithm::GTL_ERROR</a></em>&nbsp;</td><td>otherwise. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="a00001.html#76361fb03ad1cf643affc51821e43bed">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="226308389f3c36dfc02768c09f777a3b"></a><!-- doxytag: member="bellman_ford::run" ref="226308389f3c36dfc02768c09f777a3b" args="(graph &amp;G)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bellman_ford::run           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00014.html">graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies algorithm to graph g. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>graph </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67105114c20e4a96a76b5de9f28bf15e282b">algorithm::GTL_OK</a></em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00001.html#f1a0078e153aa99c24f9bdf0d97f67106fcf574690bbd6cf710837a169510dd7">algorithm::GTL_ERROR</a></em>&nbsp;</td><td>otherwise </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="a00001.html#734b189509a8d6b56b65f8ff772d43ca">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="7d28afa62ce8068c4d0f2d1f96136fd6"></a><!-- doxytag: member="bellman_ford::reset" ref="7d28afa62ce8068c4d0f2d1f96136fd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bellman_ford::reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a>. 
<p>
The weights are not reset. You can apply this algorithms twice without setting the weights for the second call. 
<p>Implements <a class="el" href="a00001.html#21aba63d066ae7897de6ca7d8425c408">algorithm</a>.</p>

</div>
</div><p>
<a class="anchor" name="98cad540fd2d211c1ba44bb6fa8416f3"></a><!-- doxytag: member="bellman_ford::source" ref="98cad540fd2d211c1ba44bb6fa8416f3" args="(const node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bellman_ford::source           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets source. 
<p>
The default source is the invalid node (<a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a>), in this case an arbitrary node is chosen and stored when this <a class="el" href="a00001.html" title="Abstract baseclass for all algoritm-classes.">algorithm</a> is run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>source. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d0cf03b1e57fc0e96ce46f772519e5b2"></a><!-- doxytag: member="bellman_ford::source" ref="d0cf03b1e57fc0e96ce46f772519e5b2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> bellman_ford::source           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns source. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>source. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e276cc9f30c2e608d320db4a08b2a74"></a><!-- doxytag: member="bellman_ford::weights" ref="9e276cc9f30c2e608d320db4a08b2a74" args="(const edge_map&lt; double &gt; &amp;weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bellman_ford::weights           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00011.html">edge_map</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weight</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets weights of the edges. 
<p>
This method <b>must</b> be called before run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>weights of the edges. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac87169a3cf4f95477ce215a0cb7a12b"></a><!-- doxytag: member="bellman_ford::store_preds" ref="ac87169a3cf4f95477ce215a0cb7a12b" args="(bool set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bellman_ford::store_preds           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the storing of predecessors. 
<p>
If enabled for every node the predecessor on the shortest path from will be stored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>if true predecessors will be stored. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html#3122381284e811ef02b7061d383eecb7" title="predecessor of node n on the shortest path from source">bellman_ford::predecessor_node</a>, <a class="el" href="a00002.html#ec75a9280a8e108b59f5f0294e4bdff0" title="edge to predecessor of node n on the shortest path from source">bellman_ford::predecessor_edge</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="46385105a5c73d364cc92276ddd8daa1"></a><!-- doxytag: member="bellman_ford::store_preds" ref="46385105a5c73d364cc92276ddd8daa1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bellman_ford::store_preds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the storing of predecessors is enabled. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>iff the storing of predecessors is enabled.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html#3122381284e811ef02b7061d383eecb7" title="predecessor of node n on the shortest path from source">bellman_ford::predecessor_node</a>, <a class="el" href="a00002.html#ec75a9280a8e108b59f5f0294e4bdff0" title="edge to predecessor of node n on the shortest path from source">bellman_ford::predecessor_edge</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="48fd2ed9748bdafeb61e5bb296ec67c6"></a><!-- doxytag: member="bellman_ford::reached" ref="48fd2ed9748bdafeb61e5bb296ec67c6" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bellman_ford::reached           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether is reachable from source. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="30203c9433e4fb628e6d5d86e2c81d5c"></a><!-- doxytag: member="bellman_ford::distance" ref="30203c9433e4fb628e6d5d86e2c81d5c" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bellman_ford::distance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the distance from source to <em>n</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec75a9280a8e108b59f5f0294e4bdff0"></a><!-- doxytag: member="bellman_ford::predecessor_edge" ref="ec75a9280a8e108b59f5f0294e4bdff0" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">edge</a> bellman_ford::predecessor_edge           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="a00010.html" title="An edge in a graph.">edge</a> to predecessor of node <em>n</em> on the shortest path from source 
<p>
If <em>n</em> is a root or wasn't reached the return value is the invalid edge <a class="el" href="a00010.html#c8047a0d7c1e08a4063be409c6fd0a88">edge::edge()</a>.<p>
<em>Please</em> <em>note</em> that this requires that this option was enabled during last run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>predecessor of <em>n</em>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html#ac87169a3cf4f95477ce215a0cb7a12b" title="Enables or disables the storing of predecessors.">bellman_ford::store_preds</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3122381284e811ef02b7061d383eecb7"></a><!-- doxytag: member="bellman_ford::predecessor_node" ref="3122381284e811ef02b7061d383eecb7" args="(const node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html">node</a> bellman_ford::predecessor_node           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
predecessor of node <em>n</em> on the shortest path from source 
<p>
If <em>n</em> is a root or wasn't reached the return value is the invalid node <a class="el" href="a00020.html#82669b7358b50bd8d7888d7df4ff8dfa">node::node()</a>.<p>
<em>Please</em> <em>note</em> that this requires that this option was enabled during last run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td><a class="el" href="a00020.html" title="A node in a graph.">node</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>predecessor of <em>n</em>. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00002.html#ac87169a3cf4f95477ce215a0cb7a12b" title="Enables or disables the storing of predecessors.">bellman_ford::store_preds</a> </dd></dl>

</div>
</div><p>
    <p class="links">
      <a href="http://www.uni-passau.de/">University of Passau</a>
      &nbsp;-&nbsp;
      <a href="http://www.fmi.uni-passau.de/">FMI</a>
      &nbsp;-&nbsp;
      <a href="http://www.fmi.uni-passau.de/fmi/lehrstuehle/brandenburg/">Theoretical
	Computer Science</a>
    </p>
  <div class="copyright">
      Design &copy; 2002, 2003 <a href="mailto:raitner@fmi.uni-passau.de">Marcus Raitner</a>,  University of Passau 
  </div>
</body>
</html>
